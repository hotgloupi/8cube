#include <cube/python.hpp>

#include <etc/log.hpp>
#include <etc/log/Logger.hpp>
#include <etc/stack_ptr.hpp>

#include <unordered_set>

namespace {

	std::string const& static_storage(std::string&& str)
	{
		static std::string out_of_memory{"out of memory"};
		static std::unordered_set<std::string> storage;
		try { return *storage.emplace(std::move(str)).first; }
		catch (...) { return out_of_memory; }
	}

	void send(etc::log::Level level,
		      std::string file,
		      etc::size_type line,
		      std::string function,
		      std::string component,
		      std::string msg)
	{
		etc::log::Log{
			level,
			static_storage(std::move(file)).c_str(),
			line,
			static_storage(std::move(function)).c_str(),
			static_storage(std::move(component)),
		}.send(std::move(msg));
	}

	struct Trace
	{
		etc::stack_ptr<etc::log::Log> log;
		etc::log::Level               level;
		std::string                   file;
		etc::size_type                line;
		std::string                   function;
		std::string                   component;
		std::string                   msg;

		Trace(etc::log::Level level,
		      std::string file,
		      etc::size_type line,
		      std::string function,
		      std::string component,
		      std::string msg)
			: log{etc::stack_ptr_no_init}
			, level{level}
			, file{std::move(file)}
			, line{line}
			, function{std::move(function)}
			, component{std::move(component)}
			, msg{std::move(msg)}
		{}

		Trace& enter()
		{
			this->log.reset(
				etc::log::Log{
					this->level,
					static_storage(std::move(this->file)).c_str(),
					this->line,
					static_storage(std::move(this->function)).c_str(),
					static_storage(std::move(this->component)),
				}.send(std::move(this->msg))
			);
			return *this;
		}

		inline
		void exit(PyObject*, PyObject*, PyObject*)
		{ this->log.clear(); }
	};

}

BOOST_PYTHON_MODULE(_log)
{
	namespace py = boost::python;
	using namespace etc::log;

	py::enum_<Level>("Level")
		.value("debug", Level::debug)
		.value("info",  Level::info)
		.value("warn",  Level::warn)
		.value("error", Level::error)
		.value("fatal", Level::fatal)
	;

	py::def("send", &send);

	py::enum_<Mode>("Mode")
		.value("asynchroneous", Mode::asynchroneous)
		.value("synchroneous", Mode::synchroneous)
	;

	py::def("set_mode", &set_mode);

	py::class_<Trace, boost::noncopyable>(
		"Trace",
		py::init<
			etc::log::Level,
			std::string,
			etc::size_type,
			std::string,
			std::string,
			std::string
		>()
	)
		.def("__enter__", &Trace::enter, py::return_internal_reference<>())
		.def("__exit__", &Trace::exit)
	;
}
