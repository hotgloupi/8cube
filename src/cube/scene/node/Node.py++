#include <cube/scene/Graph.hpp>
#include "Node.hpp"

#include <cube/exception.hpp>

#include <etc/log.hpp>
#include <etc/scope_exit.hpp>

#include <wrappers/boost/python.hpp>
#include <boost/python/raw_function.hpp>

namespace py = boost::python;
using namespace cube::scene;
using namespace cube::scene::node;
using cube::exception::Exception;

namespace {

	ETC_LOG_COMPONENT("cube.scene.Node");

	struct PythonNode
		: public Node
	{
		PyObject* _self;
		std::string _class_name;

		py::object instance() const
		{ return py::object(py::handle<>(py::borrowed(_self))); }

		PythonNode(PyObject* self, std::string name)
			: Node(std::move(name))
			, _self{self}
			, _class_name{}
		{
			try {
				_class_name = py::to_string(
					this->instance().attr("__class__").attr("__name__")
				);
			} catch (...)  { _class_name = etc::exception::string(); }
			ETC_TRACE.debug(*this, "is held by", *_self);
		}

		~PythonNode() {
			ETC_TRACE.debug(*this, "released by", *_self);
		}

		void print(std::ostream& out) const ETC_NOEXCEPT
		{
			out << "<" << _class_name << " " << this->name() << ">";
		}
	};

	std::string get_node_name(Node const& n)
	{ return n.name(); }

	void set_node_name(Node& n, std::string value)
	{ n.name(std::move(value)); }

	class PythonVisitor
		: public Visitor<Node>
	{
	private:
		py::object& _visitor;

	public:
		PythonVisitor(py::object& visitor)
			: _visitor(visitor)
		{}

		bool visit(Node& n) override
		{
			_visitor(n);
			return true;
		}
	};

	void visit_node(Node& self, py::object callable)
	{
		PythonVisitor visitor(callable);
		self.visit(visitor);
	}

	static
	PyTypeObject const* get_node_type()
	{
		auto ptr = py::converter::registered_pytype<Node>::get_pytype();
		if (ptr == nullptr)
			throw Exception{"Couldn't find PyTypeObject for Node class"};
		return ptr;
	}

	py::object node_emplace(py::tuple args, py::dict kw)
	{
		py::object node = args[0];
		py::object type = args[1];
		py::tuple ctor_args{args.slice(2, py::len(args))};
		if (!PyType_Check(type.ptr()))
		{
			PyErr_SetString(
				PyExc_ValueError,
				"First argument should be a type"
			);
			throw py::error_already_set{};
		}

		static PyTypeObject const* const node_type = get_node_type();
		if (!PyType_IsSubtype((PyTypeObject*) type.ptr(),
		                      (PyTypeObject*) node_type))
		{
			PyErr_SetString(
				PyExc_TypeError,
				"The node type must be a subclass of Node"
			);
			throw py::error_already_set{};
		}

		PyObject* result_ptr = PyObject_Call(type.ptr(), ctor_args.ptr(), kw.ptr());
		if (result_ptr == nullptr)
			throw py::error_already_set{};

		// Using py::handle<> or not has exactly the same effect ... Why ?
		//py::object result(py::handle<>(py::borrowed(result_ptr)));
		py::object result(py::borrowed(result_ptr));

		// It seems that even with borrowed(), the refcount is incremented
		//Py_INCREF(result_ptr); // XXX


		Node& self = py::extract<Node&>(node);
		auto& n = self.graph().insert(
			py::extract<Node&>(result),
			[result_ptr] (Node* n) {
				ETC_LOG.debug(*n, "Decrement refcount");
				Py_DECREF(result_ptr);
			}
		);

		n.graph().connect(self, n);
		return result;
	}

	py::object node_insert_child(Node& self, py::object py_child)
	{
		PyObject* py_child_ptr = py_child.ptr();
		Node& result = self.graph().insert(
			py::extract<Node&>(py_child),
			[py_child_ptr] (Node* n) {
				ETC_LOG.debug(*n, "Decrement refcount");
				Py_DECREF(py_child_ptr);
			}
		);

		// Insertion succeeded, the deleter will be called.
		// Py_INCREF(py_child_ptr); // XXX

		// In case of errors, we remove the inserted Node.
		auto insert_guard =
			etc::scope_exit([&] { self.graph().remove(result); });

		// Motherly bound.
		self.graph().connect(self, result);

		insert_guard.dismiss();
		return py_child;
	}

	py::tuple node_children(Node& self)
	{
		py::list l;
		for (auto child: self.graph().children(self))
			l.append(child);
		return py::tuple(l); // XXX Find a better way
	}

	struct node_to_python
	{
		static PyObject* convert(Node const& n)
		{
			if (auto o = dynamic_cast<PythonNode const*>(&n))
			{
				ETC_LOG.debug("Retrieve python object", *o->_self, "of", n);
				return py::incref(o->_self);
			}
			ETC_LOG.debug("Build python instance of", n);
			return py::incref(py::object(py::ptr(&n)).ptr());
		}
	};
}


BOOST_PYTHON_MODULE(Node)
{
	py::class_<Node, PythonNode, boost::noncopyable>("Node", py::init<std::string>())
		.add_property("name", &get_node_name, &set_node_name)
		.def( "__str__", &py::stringof<Node> )
		.def("visit", &visit_node)
		.def("emplace_child", py::raw_function(&node_emplace))
		.def("insert_child", &node_insert_child)
		.add_property("children", &node_children)
	;

	py::to_python_converter<Node, node_to_python>();
}
