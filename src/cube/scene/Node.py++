#include "Graph.hpp"
#include "Node.hpp"

#include <cube/exception.hpp>

#include <wrappers/boost/python.hpp>
#include <boost/python/raw_function.hpp>

namespace py = boost::python;
using namespace cube::scene;
using cube::exception::Exception;

namespace {

	std::string get_node_name(Node const& n)
	{ return n.name(); }

	void set_node_name(Node& n, std::string value)
	{ n.name(std::move(value)); }

	class PythonVisitor
		: public NodeVisitor<Node>
	{
	private:
		py::object& _visitor;

	public:
		PythonVisitor(py::object& visitor)
			: _visitor(visitor)
		{}

		bool visit(Node& n) override
		{
			// boost::ref is needed, otherwise boost::python would search for
			// a converter.
			_visitor(boost::ref(n));
			return true;
		}
	};

	void visit_node(Node& self, py::object callable)
	{
		PythonVisitor visitor(callable);
		self.visit(visitor);
	}

	static
	PyTypeObject const* get_node_type()
	{
		auto ptr = py::converter::registered_pytype<Node>::get_pytype();
		if (ptr == nullptr)
			throw Exception{"Couldn't find PyTypeObject for Node class"};
		return ptr;
	}

	py::object node_emplace(py::tuple args, py::dict kw)
	{
		py::object node = args[0];
		py::object type = args[1];
		py::tuple ctor_args{args.slice(2, py::len(args))};
		if (!PyType_Check(type.ptr()))
		{
			PyErr_SetString(
				PyExc_ValueError,
				"First argument should be a type"
			);
			throw py::error_already_set{};
		}

		static PyTypeObject const* const node_type = get_node_type();
		if (!PyType_IsSubtype((PyTypeObject*) type.ptr(),
		                      (PyTypeObject*) node_type))
		{
			PyErr_SetString(
				PyExc_TypeError,
				"The node type must be a subclass of Node"
			);
			throw py::error_already_set{};
		}

		PyObject* result_ptr = PyObject_Call(type.ptr(), ctor_args.ptr(), kw.ptr());
		if (result_ptr == nullptr)
			throw py::error_already_set{};

		// Using py::handle<> or not has exactly the same effect ... Why ?
		//py::object result(py::handle<>(py::borrowed(result_ptr)));
		py::object result(py::borrowed(result_ptr));

		// It seems that even with borrowed(), the refcount is incremented
		Py_DECREF(result_ptr);


		Node& self = py::extract<Node&>(node);
		auto& n = self.graph().insert(
			py::extract<Node&>(result),
			[result_ptr] (Node* n) { if (n->attached()) { Py_DECREF(result_ptr); }}
		);

		n.graph().connect(self, n);
		return result;
	}
}



BOOST_PYTHON_MODULE(Node)
{
	py::class_<Node, boost::noncopyable>("Node", py::init<std::string>())
		.add_property("name", &get_node_name, &set_node_name)
		.def( "__str__", &py::stringof<Node> )
		.def("visit", &visit_node)
		.def("emplace", py::raw_function(&node_emplace))
	;
}
