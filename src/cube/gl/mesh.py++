#include <cube/python.hpp>
#include <boost/python/raw_function.hpp>

#include "mesh.hpp"

#include "exception.hpp"
#include "renderer/Renderer.hpp"
#include "renderer/Drawable.hpp"

#include <etc/to_string.hpp>

namespace {

	struct Proxy
	{
		struct Mesh
		{
			static
			boost::python::object
			append(boost::python::tuple args,
			       boost::python::dict kwargs)
			{
				namespace py = boost::python;
				using cube::gl::mesh::Mesh;
				if (py::len(kwargs))
					throw cube::gl::exception::Exception{
						"Mesh.append() does not accept named arguments"
					};
				Mesh& mesh = py::extract<Mesh&>(args[0])();
				for (int i = 1, len = py::len(args); i < len; ++i)
				{
					auto el = args[i];
#define CHECK(__type) \
					{ \
						py::extract<__type> e(el); \
						if (e.check()) \
						{ \
							mesh.append(e()); \
							continue; \
						} \
					} \
/**/
					CHECK(Mesh::Mode);
					CHECK(Mesh::Kind);
					CHECK(Mesh::vertex_t);
					CHECK(Mesh::color3_t);
					CHECK(Mesh::color4_t);
					CHECK(Mesh::tex_coord_t);
					std::string s = py::extract<std::string>(py::str(el));
					throw cube::gl::exception::Exception{
						etc::to_string("Cannot add", s, "to a mesh")
					};
				}
				return args[0];
			}

		};
	};
}

BOOST_PYTHON_MODULE(mesh)
{
	using namespace cube::gl::mesh;
	namespace py = boost::python;

	py::class_<Mesh, boost::noncopyable, MeshPtr>("Mesh")
		.def(py::init<Mesh::Kind>())
		.def(py::init<Mesh::Kind, Mesh::Mode>())
		.add_property(
			"mode",
			static_cast<Mesh::Mode (Mesh::*)() const>(&Mesh::mode),
			py::make_function(
				static_cast<Mesh& (Mesh::*)(Mesh::Mode const)>(&Mesh::mode),
				py::return_internal_reference<>()
			)
		)
		.add_property(
			"kind",
			static_cast<Mesh::Kind (Mesh::*)() const>(&Mesh::kind),
			py::make_function(
				static_cast<Mesh& (Mesh::*)(Mesh::Kind const)>(&Mesh::kind),
				py::return_internal_reference<>()
			)
		)
		.def("append", py::raw_function(&Proxy::Mesh::append, 1))
		.def(
				"drawable",
				&Mesh::drawable,
				py::return_value_policy<
				    py::return_by_value
				  , py::with_custodian_and_ward_postcall<0, 2>
				>()
		)
		.def("__str__", &py::stringof<Mesh>)
	;
}
