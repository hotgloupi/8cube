#include "Light.hpp"
#include "PainterWithProxy.hpp"
#include "Renderer.hpp"
#include "ShaderGenerator.hpp"
#include "ShaderProgram.hpp"
#include "Texture.hpp"
#include "VertexBufferAttribute.hpp"
#include "VertexBuffer.hpp"

#include <cube/system/window.hpp>
#include <cube/gl/exception.hpp>
#include <cube/gl/surface.hpp>

#include <wrappers/boost/python.hpp>

namespace {

	namespace renderer = cube::gl::renderer;
	namespace py = boost::python;

	struct Wrap
	{
		struct Renderer
		{
			static
			renderer::PainterWithProxy
			begin(renderer::Renderer& self,
			      renderer::Mode mode)
			{
				return renderer::PainterWithProxy(self, mode);
			}

			static
			void
			clear(renderer::Renderer& self,
			      int const buffer_bit)
			{
				self.clear(
					static_cast<renderer::BufferBit>(buffer_bit)
				);
			}

			static
			void
			viewport(renderer::Renderer& self,
			         int x, int y, int w, int h)
			{
				self.viewport(
					cube::gl::viewport::Viewport(x, y, w, h)
				);
			}

			template<
				  typename T
				, template<typename...> class from_ptr
				, template<typename...> class to_ptr
			>
			struct convert_ptr
			{
				// Default conversion is just a move
				static inline
				to_ptr<T> convert(from_ptr<T>&& ptr)
				{ return std::move(ptr); }
			};

			template<typename T>
			struct convert_ptr<T, std::auto_ptr, std::unique_ptr>
			{
				// Release from one to another.
				static inline
				std::unique_ptr<T> convert(std::auto_ptr<T>&& ptr)
				{
					std::unique_ptr<T> res(ptr.get());
					ptr.release();
					return std::move(res);
				}
			};

			template<
				  typename T
				, template<typename...> class smart_ptr = std::unique_ptr
				, template<typename...> class storage_ptr = std::auto_ptr
			>
			static
			std::vector<smart_ptr<T>>
			_list_to_vector(boost::python::list& args)
			{
				size_t len = boost::python::len(args);
				std::vector<smart_ptr<T>> ptrs;
				for (size_t i = 0; i < len; ++i)
				{
					storage_ptr<T>& ptr =
						boost::python::extract<storage_ptr<T>&>(args[i]);
					if (ptr.get() == nullptr)
						throw cube::gl::exception::Exception{
							"Found a null pointer in the list!"
						};
					ptrs.emplace_back(
						convert_ptr<T, storage_ptr, smart_ptr>::convert(
							std::move(ptr)
						)
					);
					args[i] = boost::python::object{};
				}
				return ptrs;
			}

			static
			renderer::ShaderProgramPtr
			new_shader_program(renderer::Renderer& self,
			                   boost::python::list args)
			{
				return self.new_shader_program(
					_list_to_vector<renderer::Shader, std::shared_ptr, std::shared_ptr>(args)
				);
			}

			static
			renderer::ShaderGeneratorProxy
			generate_shader(renderer::Renderer& self,
			                renderer::ShaderType const type)
			{
				return self.generate_shader(type);
			}

			static
			renderer::VertexBufferPtr
			new_vertex_buffer(renderer::Renderer& self,
			                  boost::python::list args)
			{
				return self.new_vertex_buffer(
					_list_to_vector<renderer::VertexBufferAttribute>(args)
				);
			}

			static
			renderer::VertexBufferPtr
			new_index_buffer(renderer::Renderer& self,
			                 std::auto_ptr<renderer::VertexBufferAttribute>& attr)
			{
				return self.new_index_buffer(
					renderer::VertexBufferAttributePtr{attr.release()}
				);
			}


			static
			renderer::ShaderPtr
			new_vertex_shader(renderer::Renderer& self,
			                  std::vector<std::string> const& srcs)
			{
				return self.new_vertex_shader(srcs);
			}

			static
			renderer::ShaderPtr
			new_fragment_shader(renderer::Renderer& self,
			                    std::vector<std::string> const& srcs)
			{
				return self.new_fragment_shader(srcs);
			}

			static
			renderer::LightPtr
			new_light(renderer::Renderer& self,
			          std::auto_ptr<renderer::CustomLightInfo>& info)
			{
				return self.new_light(
					renderer::CustomLightInfoPtr{info.release()}
				);
			}
		};

	};

	template<typename T>
	struct vector_from_python
	{
		vector_from_python()
		{
		}

		static
		void* convertible(PyObject* ptr)
		{
			// is convertible from list and tuple. if len(ptr) > 0,
			if (PyList_Check(ptr) || PyTuple_Check(ptr))
				return ptr;
			return nullptr;
		}

		static
		void construct(PyObject* ptr,
		               py::converter::rvalue_from_python_stage1_data* data)
		{
			typedef PyObject* (*extractor_t)(PyObject*, ssize_t);

			extractor_t extractor;
			Py_ssize_t len;

			if (PyList_Check(ptr))
			{
				extractor = &PyList_GetItem;
				len = PyList_Size(ptr);
			}
			else if (PyTuple_Check(ptr))
			{
				extractor = &PyTuple_GetItem;
				len = PyTuple_Size(ptr);
			}
			else
				throw cube::gl::exception::Exception{
					"convertible has messed up"
				};

			typedef py::converter::rvalue_from_python_storage<std::vector<T>> storage_t;

			// Grab pointer to memory into which to construct the new QString
			void* storage = ((storage_t*) data)->storage.bytes;

			assert(storage != nullptr && "Boost.Python gave a null storage");

			// in-place construct the new std::vector<std::string>.
			auto vec = new (storage) std::vector<T>{};

			for (Py_ssize_t i = 0; i < len; ++i)
			{
				PyObject* item = (*extractor)(ptr, i);
				boost::python::object obj{boost::python::borrowed(item)};
				vec->emplace_back(boost::python::extract<T>(obj));
			}

			// Stash the memory chunk pointer for later use by boost.python
			data->convertible = storage;
		}
	};

} //!anonymous



BOOST_PYTHON_MODULE(Renderer)
{
	using namespace ::cube::gl::renderer;

	py::converter::registry::push_back(
		&vector_from_python<std::string>::convertible,
		&vector_from_python<std::string>::construct,
		py::type_id<std::vector<std::string>>()
	);

	typedef TexturePtr (Renderer::*new_texture_cb_t)(std::string const&);

	typedef TexturePtr (Renderer::*new_texture_raw_cb_t)(
		PixelFormat const,
		unsigned int,
		unsigned int,
		renderer::PixelFormat const,
		renderer::ContentPacking const,
		void const*
	);

	typedef ShaderPtr (Renderer::*new_fragment_shader_t)(
		std::vector<std::string> const&,
		Shader::Parameters,
		Shader::Parameters,
		Shader::Parameters
	);

	typedef ShaderPtr (Renderer::*new_vertex_shader_t)(
		std::vector<std::string> const&,
		Shader::Parameters,
		Shader::Parameters,
		Shader::Parameters
	);

	typedef LightPtr (Renderer::*new_custom_light_t)(CustomLightInfoPtr);

	typedef py::return_value_policy<
		py::return_by_value,
		py::with_custodian_and_ward_postcall<0, 1>
	> return_internal_value_policy;

	py::class_<Renderer, std::auto_ptr<Renderer>, boost::noncopyable>(
			"Renderer", py::no_init
		)
		.add_property(
			"description",
			py::make_function(
				&Renderer::description,
				py::return_internal_reference<>()
			)
		)
		.add_property(
			"viewport",
			py::make_function(
				static_cast<cube::gl::viewport::Viewport const& (Renderer::*)() const>(&Renderer::viewport),
				py::return_value_policy<py::copy_const_reference>()
			)
		)
		.add_property(
			"context",
			py::make_function(&Renderer::context, py::return_internal_reference<>())
		)
		.def(
			"begin",
			&Wrap::Renderer::begin,
			return_internal_value_policy()
		)
		.add_property(
			"state",
			py::make_function(
				&Renderer::current_state,
				py::return_internal_reference<>()
			)
		)
		.def(
			"new_vertex_buffer",
			&Wrap::Renderer::new_vertex_buffer,
			return_internal_value_policy()
		)
		.def(
			"new_index_buffer",
			&Wrap::Renderer::new_index_buffer,
			return_internal_value_policy()
		)
		.def(
			"generate_shader",
			&Wrap::Renderer::generate_shader,
			return_internal_value_policy()
		)
		.def(
			"new_shader",
			&Renderer::new_shader,
			return_internal_value_policy()
		)
		.def(
			"new_shader_program",
			&Wrap::Renderer::new_shader_program,
			return_internal_value_policy()
		)
		.def(
			"new_vertex_shader",
			static_cast<new_vertex_shader_t>(&Renderer::new_vertex_shader),
			return_internal_value_policy()
		)
		.def(
			"new_vertex_shader",
			&Wrap::Renderer::new_vertex_shader,
			return_internal_value_policy()
		)
		.def(
			"new_fragment_shader",
			static_cast<new_fragment_shader_t>(&Renderer::new_fragment_shader),
			return_internal_value_policy()
		)
		.def(
			"new_fragment_shader",
			&Wrap::Renderer::new_fragment_shader,
			return_internal_value_policy()
		)
		.def(
			"new_texture",
			&Renderer::new_texture,
			return_internal_value_policy()
		)
		.def(
			"new_light",
			&Renderer::new_light<LightKind::directional>,
			return_internal_value_policy()
		)
		.def(
			"new_light",
			&Renderer::new_light<LightKind::spot>,
			return_internal_value_policy()
		)
		.def(
			"new_light",
			&Renderer::new_light<LightKind::point>,
			return_internal_value_policy()
		)
		.def(
			"new_light",
			&Wrap::Renderer::new_light,
			return_internal_value_policy()
		)
		.def(
			"clear",
			&Wrap::Renderer::clear
		)
		.def(
			"flush",
			&Renderer::flush
		)
	;

	///////////////////////////////////////////////////////////////////////////
	// RendererType

	py::class_<RendererType, boost::noncopyable>(
			"RendererType",
			py::no_init
		)
		.add_property("name", &RendererType::name)
		.def(
			"__str__",
			&RendererType::__str__
		)
	;
}
