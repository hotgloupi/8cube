#include "ShaderGenerator.hpp"
#include "Shader.hpp"

#include <etc/print.hpp>
#include <etc/scope_exit.hpp>

#include <wrappers/boost/python.hpp>
#include <boost/python/raw_function.hpp>

namespace
{
	namespace py = boost::python;
	using namespace ::cube::gl::renderer;

	struct ShaderRoutineWrap
		: public ShaderRoutine
		, public py::wrapper<ShaderRoutine>
	{
		PyObject* object;

		ShaderRoutineWrap(ShaderGeneratorProxy& proxy,
		                  std::string name)
			: ShaderRoutine{proxy, std::move(name)}
			, object{nullptr}
		{}

		~ShaderRoutineWrap()
		{ Py_XDECREF(this->object); }

		std::string
		source(ShaderLanguage lang) const override
		{
			if (auto fn = this->get_override("source"))
				return fn(lang);
			return ShaderRoutine::source(lang);
		}

		bool is_applicable(ShaderType type) const ETC_NOEXCEPT override
		{
			return this->get_override("is_applicable")(type);
		}
	};

	template<typename T>
	inline
	PyTypeObject const* registered_pytype()
	{ return py::converter::registered_pytype<T>::get_pytype(); }

	PyTypeObject const* get_shader_routine_type()
	{
		auto ptr = registered_pytype<ShaderRoutineWrap>();
		if (ptr == nullptr)
			throw Exception{"Couldn't find PyTypeObject for Routine class"};
		return ptr;
	}

	static
	py::object add_routine(py::tuple args,
	                       py::dict kw)
	{
		ShaderGeneratorProxy& self =
			py::extract<ShaderGeneratorProxy&>(args[0]);
		py::object routine_cls = args[1];
		if (!PyType_Check(routine_cls.ptr()))
		{
			PyErr_SetString(
				PyExc_ValueError,
				"First argument should be a type"
			);
			throw py::error_already_set{};
		}
		static PyTypeObject const* const type = get_shader_routine_type();
		if (!PyType_IsSubtype((PyTypeObject*) routine_cls.ptr(),
		                      (PyTypeObject*) type))
		{
			PyErr_SetString(
				PyExc_TypeError,
				"The routine type must be a subclass of ShaderRoutine"
			);
			throw py::error_already_set{};
		}

		py::list ctor_args;
		ctor_args.append(self);
		ctor_args.extend(args.slice(2, py::len(args)));
		PyObject* result_ptr = PyObject_Call(
			routine_cls.ptr(), py::tuple(ctor_args).ptr(), kw.ptr()
		);
		if (result_ptr == nullptr)
			throw py::error_already_set{};
		py::object result{py::handle<>(py::borrowed(result_ptr))};

		try
		{
			std::shared_ptr<ShaderRoutineWrap>& ptr =
				py::extract<std::shared_ptr<ShaderRoutineWrap>&>(result);
			if (ptr == nullptr)
				throw Exception("Null routine");
			ptr->object = result_ptr;
			self.raw_routine(ptr);
			ptr.reset();
		}
		catch (py::error_already_set const&)
		{
			PyErr_SetString(
				PyExc_TypeError,
				"Couldn't cast the created routine to the Routine type "
				"(You might have forgotten to call Routine.__init__)"
			);
			throw;
		}
		return args[0];
	}

}

BOOST_PYTHON_MODULE(ShaderGenerator)
{
	namespace py = boost::python;
	using namespace ::cube::gl::renderer;

	py::class_<
		ShaderGenerator,
		std::auto_ptr<ShaderGenerator>,
		boost::noncopyable
	>("ShaderGenerator", py::no_init)
	;

	typedef
		ShaderGeneratorProxy&
		(ShaderGeneratorProxy::*set_param_t)(ShaderParameterType const,
		                                     std::string const&);

	typedef
		ShaderGeneratorProxy&
		(ShaderGeneratorProxy::*set_param_kind_t)(ShaderParameterType const,
		                                          std::string const&,
		                                          ContentKind const);

	typedef py::return_self<> return_self;
	py::class_<ShaderGeneratorProxy>("ShaderGeneratorProxy", py::no_init)
		.def_readonly("type", &ShaderGeneratorProxy::type)
		.def_readonly("parameters", &ShaderGeneratorProxy::parameters)
		.def_readonly("inputs", &ShaderGeneratorProxy::inputs)
		.def_readonly("outputs", &ShaderGeneratorProxy::outputs)
		.add_property("source", &ShaderGeneratorProxy::source)
		.def("shader", &ShaderGeneratorProxy::shader)
		.def(
			"input",
			static_cast<set_param_t>(&ShaderGeneratorProxy::input),
			return_self()
		)
		.def(
			"input",
			static_cast<set_param_kind_t>(&ShaderGeneratorProxy::input),
			return_self()
		)
		.def(
			"output",
			static_cast<set_param_t>(&ShaderGeneratorProxy::output),
			return_self()
		)
		.def(
			"output",
			static_cast<set_param_kind_t>(&ShaderGeneratorProxy::output),
			return_self()
		)
		.def(
			"parameter",
			static_cast<set_param_t>(&ShaderGeneratorProxy::parameter),
			return_self()
		)
		.def("routine", py::raw_function(&add_routine))
	;


	py::class_<
		ShaderRoutineWrap,
		boost::noncopyable,
		std::shared_ptr<ShaderRoutineWrap>
	>("ShaderRoutine", py::init<ShaderGeneratorProxy&, std::string>())
		.def("is_applicable", &ShaderRoutineWrap::is_applicable)
		.def("source", &ShaderRoutineWrap::source)
	;
}
