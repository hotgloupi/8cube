#include "font.hpp"
#include "renderer/Texture.hpp"
#include "renderer/Renderer.hpp"
#include "renderer.hpp"
#include "renderer/VertexBuffer.hpp"

#include <wrappers/boost/python.hpp>

namespace py = boost::python;
using namespace cube::gl;

namespace {

	struct Proxy
	{
		struct Font
		{
			template<typename CharType>
			static
			renderer::VertexBufferPtr
			generate_text(font::Font& self, CharType const* str)
			{
				assert(str != nullptr && "Null string !");
				return self.generate_text(
					std::basic_string<CharType>(str)
				);
			}

			static
			py::object
			get_infos(std::string const& path)
			{
				py::list res;
				for (auto& info: font::get_infos(path))
					res.append(py::ptr(info.release()));
				return res;
			}
		};

		struct Infos
		{
			static
			std::string str(font::Infos const& infos)
			{
				return etc::to_string(infos);
			}
		};

		struct Style
		{
			static
			std::string str(font::Style const style)
			{
				return etc::to_string(style);
			}
		};
	};

	struct FontInfosPickleSuite
		: py::pickle_suite
	{
		static
		py::tuple getinitargs(font::Infos const& infos)
		{
			return py::make_tuple(
				infos.path,
				infos.family_name,
				infos.style_name,
				infos.style,
				infos.has_horizontal,
				infos.has_vertical,
				infos.is_fixed_width,
				infos.is_scalable,
				infos.has_bitmaps,
				infos.support_kerning,
				infos.face_index
			);
		}
/*
		static
		py::tuple getstate(font::Infos const& infos)
		{
			// ...
		}

		static
		void setstate(font::Infos& infos, boost::python::tuple state)
		{
			// ...
		}
*/
	};

} // !anonymous

BOOST_PYTHON_MODULE(font)
{
	BOOST_PYTHON_DOCSTRING_OPTIONS();
	py::class_<font::Font, boost::noncopyable>(
			"Font",
			py::init<
				  renderer::Renderer&
				, font::Infos const&
				, etc::size_type
			>()
		)
		.def(
			"generate_text",
			&Proxy::Font::generate_text<char>,
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<0, 1>
			>()
		)
		.add_property(
			"texture",
			py::make_function(
				&font::Font::texture,
				py::return_internal_reference<>()
			)
		)
	;

	py::def("is_valid", &font::is_valid);

	py::class_<font::Infos, boost::noncopyable>(
			"Infos",
			py::init<
				std::string const&,
				std::string const&,
				std::string const&,
				font::Style const,
				bool,
				bool,
				bool,
				bool,
				bool,
				bool,
				etc::size_type
			>()
		)
		.def_readonly("path", &font::Infos::path)
		.def_readonly("family_name", &font::Infos::family_name)
		.def_readonly("style_name", &font::Infos::style_name)
		.def_readonly("style", &font::Infos::style)
		.def_readonly("has_horizontal", &font::Infos::has_horizontal)
		.def_readonly("has_vertical", &font::Infos::has_vertical)
		.def_readonly("is_fixed_width", &font::Infos::is_fixed_width)
		.def_readonly("is_scalable", &font::Infos::is_scalable)
		.def_readonly("has_bitmaps", &font::Infos::has_bitmaps)
		.def_readonly("support_kerning", &font::Infos::support_kerning)
		.def("__str__", &Proxy::Infos::str)
		.def_pickle(FontInfosPickleSuite{})
	;

	py::def(
		"get_infos",
		&Proxy::Font::get_infos/*,
		py::return_value_policy<py::manage_new_object>()*/
	);

	{
		py::scope Style_scope = py::enum_<font::Style>("Style")
			.value("regular", font::Style::regular)
			.value("bold", font::Style::bold)
			.value("italic", font::Style::italic)
			.value("bold_italic", font::Style::bold_italic)
		;

		py::def("__str__", &Proxy::Style::str);
	}
}
