#include "Material.hpp"
#include <cube/gl/renderer/Renderer.hpp>
#include <cube/gl/renderer/Bindable.hpp>

#include <cube/python.hpp>
#include <cube/converters.hpp>

namespace {

	using namespace cube::gl::material;

	template<typename ReturnType>
	auto getter_cast(ReturnType (Material::*ptr)() const)
		-> ReturnType (Material::*)() const
	{ return ptr; }

	template<typename Arg>
	auto setter_cast(void (Material::*ptr)(Arg))
		-> void (Material::*)(Arg)
	{ return ptr; }

	cube::gl::renderer::TexturePtr
	get_texture(cube::gl::material::Material::TextureChannel& self)
	{ return self.texture; }

}

BOOST_PYTHON_MODULE(Material)
{
	namespace py = boost::python;
	using namespace cube::gl::material;
	namespace renderer = cube::gl::renderer;

	cube::register_vector_converter<Material::TextureChannel>();


	py::enum_<TextureMapping>("TextureMapping")
		.value("uv", TextureMapping::uv)
		.value("sphere", TextureMapping::sphere)
		.value("cylinder", TextureMapping::cylinder)
		.value("box", TextureMapping::box)
		.value("plane", TextureMapping::plane)
	;

	py::enum_<StackOperation>("StackOperation")
		.value("multiply", StackOperation::multiply)
		.value("add", StackOperation::add)
		.value("subtract", StackOperation::subtract)
		.value("divide", StackOperation::divide)
		.value("smooth_add", StackOperation::smooth_add)
		.value("signed_add", StackOperation::signed_add)
	;

	py::enum_<TextureMapMode>("TextureMapMode")
		.value("wrap", TextureMapMode::wrap)
		.value("clamp", TextureMapMode::clamp)
		.value("decal", TextureMapMode::decal)
		.value("mirror", TextureMapMode::mirror)
	;

	py::enum_<BlendMode>("BlendMode")
		.value("basic", BlendMode::basic)
		.value("additive", BlendMode::additive)
	;

	py::enum_<TextureType>("TextureType")
		.value("diffuse", TextureType::diffuse)
		.value("specular", TextureType::specular)
		.value("ambient", TextureType::ambient)
		.value("emissive", TextureType::emissive)
		.value("height", TextureType::height)
		.value("normals", TextureType::normals)
		.value("shininess", TextureType::shininess)
		.value("opacity", TextureType::opacity)
		.value("displacement", TextureType::displacement)
		.value("lightmap", TextureType::lightmap)
		.value("reflection", TextureType::reflection)
	;

	py::enum_<ShadingModel>("ShadingModel")
		.value("none", ShadingModel::none)
		.value("gouraud", ShadingModel::gouraud)
	;

	typedef void (Material::*add_texture_t)(renderer::TexturePtr&,
	                                        TextureType,
	                                        TextureMapping,
	                                        StackOperation,
	                                        TextureMapMode,
	                                        float);

	typedef void (Material::*add_texture_path_t)(std::string,
	                                             TextureType,
	                                             TextureMapping,
	                                             StackOperation,
	                                             TextureMapMode,
	                                             float);
	typedef Material::TextureChannels const& (Material::*get_textures_t)() const;

	{
		auto cls = py::class_<Material, boost::noncopyable, MaterialPtr>("Material")
			.def(py::init<std::string>())
#define ADD_PROPERTY(__name) \
			.add_property( \
				#__name, \
				py::make_function( \
					getter_cast(&Material::__name), \
					py::return_value_policy<py::return_by_value>() \
				), \
				py::make_function( \
					setter_cast(&Material::__name) \
				) \
			) \
	/**/
			ADD_PROPERTY(name)
			ADD_PROPERTY(ambient)
			ADD_PROPERTY(ambiant)
			ADD_PROPERTY(diffuse)
			ADD_PROPERTY(specular)
			ADD_PROPERTY(shininess)
			ADD_PROPERTY(opacity)
			ADD_PROPERTY(shading_model)
#undef ADD_PROPERTY
			.def("add_color", &Material::add_color)
			.def(
				"add_texture",
				static_cast<add_texture_t>(&Material::add_texture)
			)
			.def(
				"add_texture",
				static_cast<add_texture_path_t>(&Material::add_texture)
			)
			.def("bindable", &Material::bindable)
			.add_property(
				"textures",
				py::make_function(
					static_cast<get_textures_t>(&Material::textures),
					py::return_value_policy<py::return_by_value>()
				)
			)
		;
		py::class_<Material::TextureChannel>(
			"TextureChannel",
			py::no_init
		)
			.def_readonly("path", &Material::TextureChannel::path)
			.add_property(
				"texture",
				py::make_function(
					&get_texture,
					py::return_value_policy<py::return_by_value>()
					//py::return_internal_reference<>()
				)
			)
			.def_readonly("type", &Material::TextureChannel::type)
		;
	}
}
