#include <wrappers/boost/python.hpp>
#include <boost/python/raw_function.hpp>
#include <string>

#include "renderer.hpp"
#include "renderer/Bindable.hpp"
#include "renderer/Drawable.hpp"
#include "renderer/Shader.hpp"
#include "renderer/ShaderProgram.hpp"
#include "renderer/Texture.hpp"

#include "color.hpp"

#include <etc/print.hpp>

using namespace cube::gl::renderer;

namespace renderer = cube::gl::renderer;

namespace {

	///////////////////////////////////////////////////////////////////////////
	// Wrap some class method here

	struct Wrap
	{

		///////////////////////////////////////////////////////////////////////
		// Renderer

		struct Renderer
		{
			static
			detail::PainterWithProxy
			begin(renderer::Renderer& self,
			      renderer::Mode mode)
			{
				return detail::PainterWithProxy(self, mode);
			}

			static
			void
			clear(renderer::Renderer& self,
			      int buffer_bit)
			{
				self.clear(
					static_cast<cube::gl::renderer::BufferBit>(buffer_bit)
				);
			}

			static
			void
			viewport(renderer::Renderer& self,
			         int x, int y, int w, int h)
			{
				self.viewport(
					cube::gl::viewport::Viewport(x, y, w, h)
				);
			}

			template<typename T>
			static
			std::vector<std::unique_ptr<T>>
			_tuple_to_vector(boost::python::tuple& args)
			{
				size_t len = boost::python::len(args);
				std::vector<std::unique_ptr<T>> ptrs;
				for (size_t i = 0; i < len; ++i)
				{
					std::auto_ptr<T> ptr =
						boost::python::extract<std::auto_ptr<T>>(args[i]);
					ptrs.emplace_back(ptr.release());
				}
				return ptrs;
			}

			static
			renderer::ShaderProgramPtr
			new_shader_program(renderer::Renderer& self,
			                   boost::python::tuple args)
			{
				return self.new_shader_program(
					_tuple_to_vector<renderer::Shader>(args)
				);
			}

			static
			renderer::VertexBufferPtr
			new_vertex_buffer(renderer::Renderer& self,
			                  boost::python::tuple args)
			{
				return self.new_vertex_buffer(
					_tuple_to_vector<renderer::VertexBufferAttribute>(args)
				);
			}

			static
			renderer::VertexBufferPtr
			new_index_buffer(renderer::Renderer& self,
			                 std::auto_ptr<VertexBufferAttribute>& attr)
			{
				return self.new_index_buffer(
					VertexBufferAttributePtr{attr.release()}
				);
			}

		};

		///////////////////////////////////////////////////////////////////////
		// Convert unique_ptr

		// This is involved when returning by value, and as copying is not
		// allowed for a unique_ptr, we can safely remove de const qualifiers.
		// This is meant to happen when returning unique_ptr<T>, for the
		// caller, the variable is moved.
		//
		// When boost python handle properly to move operation, this could go
		// away.

		template<typename T>
		struct UniquePtrConverter
		{
			static
			PyObject* convert(std::unique_ptr<T> const& value)
			{
				return boost::python::incref(
					boost::python::object(
						std::auto_ptr<T>(
							const_cast<std::unique_ptr<T>&>(value).release()
						)
					).ptr()
				);
			}
		};

		///////////////////////////////////////////////////////////////////////
		// Painter

		struct Painter
		{
			static
			void bind(renderer::Painter& self, renderer::Bindable<>& o)
			{
				self.bind(o);
			}
		};

		///////////////////////////////////////////////////////////////////////
		// PainterWithProxy

		struct PainterWithProxy
		{
			static
			void
			__exit__(detail::PainterWithProxy& self, PyObject*, PyObject*, PyObject*)
			{
				self.__exit__();
			}
		};

		///////////////////////////////////////////////////////////////////////
		// VertexBuffer
/*
		struct VertexBuffer
		{
			template<typename T>
			static
			void
			_push_static_content(renderer::VertexBuffer& self,
			                     ContentKind kind,
			                     boost::python::list list,
			                     size_t len)
			{
				std::unique_ptr<T, void(*)(void*)> array{
					static_cast<T*>(::malloc(len * sizeof (T))),
					&std::free
				};
				for (size_t i = 0; i < len; ++i)
				{
					boost::python::object elem = list[i];
					array.get()[i] = boost::python::extract<T>(elem);
				}
				self.push_static_content(kind, std::move(array), len);
			}

			static
			void
			push_static_content(renderer::VertexBuffer& self,
			                    ContentKind kind,
			                    boost::python::list list)
			{
				size_t len = boost::python::len(list);
				if (len == 0)
					throw std::runtime_error("empty content");

				boost::python::object first = list[0];

#define _CHECK(type) \
				if (boost::python::extract<type>(first).check()) \
					return _push_static_content<type>(self, kind, list, len)

				switch (kind)
				{
					case ContentKind::color:
						_CHECK(cube::gl::color::Color3f);
						_CHECK(cube::gl::color::Color4f);
						break;
					case ContentKind::index:
						_CHECK(uint8_t);
						_CHECK(uint16_t);
						_CHECK(uint32_t);
						break;
					default:
						_CHECK(cube::gl::vector::Vector2f);
						_CHECK(cube::gl::vector::Vector3f);

				}
#undef _CHECK

				throw std::runtime_error(
					"List content has to be a color or a vector, got '" +
					std::string(
						boost::python::extract<std::string>(
							boost::python::str(first)
						)
					) + "'."
				);
			}
		};
*/

	}; // !struct Wrap

} // !anonymous


// py::raw_function compatible
//static boost::python::object
//Renderer_Painter_draw(boost::python::tuple args,
//                      boost::python::dict kwargs)
//{
//	size_t len = boost::python::len(args);
//	Painter& self = boost::python::extract<Painter&>(args[0]);
//
//	std::vector<Bindable*> to_draw;
//
//	for (size_t i = 1; i < len; ++i)
//	{
//		Bindable* drawable = boost::python::extract<Drawable*>(args[i]);
//		to_draw.push_back(drawable);
//	}
//	self.draw(to_draw);
//	return boost::python::object{};
//}


BOOST_PYTHON_MODULE(renderer)
{
	namespace py = boost::python;

	py::enum_<Mode>(
			"RendererMode",
			"Renderer mode affects default projection matrices"
		)
		.value("mode_2d", Mode::_2d)
		.value("mode_3d", Mode::_3d)
		.export_values()
		.value("none", Mode::none)
		.value("_2d", Mode::_2d)
		.value("_3d", Mode::_3d)
	;

	py::enum_<ContentKind>("ContentKind")
		.value("vertex", ContentKind::vertex)
		.value("index", ContentKind::index)
		.value("color", ContentKind::color)
		.value("normal", ContentKind::normal)
		.value("tex_coord0", ContentKind::tex_coord0)
		.value("tex_coord1", ContentKind::tex_coord1)
		.value("tex_coord2", ContentKind::tex_coord2)
	;

	py::enum_<ContentPacking>("ContentPacking")
		.value("uint8", ContentPacking::uint8)
		.value("int8", ContentPacking::int8)
		.value("uint16", ContentPacking::uint16)
		.value("int16", ContentPacking::int16)
		.value("uint32", ContentPacking::uint32)
		.value("int32", ContentPacking::int32)
		.value("float32", ContentPacking::float32)
		.value("uint8_3_3_2", ContentPacking::uint8_3_3_2)
		.value("uint8_2_3_3_rev", ContentPacking::uint8_2_3_3_rev)
		.value("uint16_5_6_5", ContentPacking::uint16_5_6_5)
		.value("uint16_5_6_5_rev", ContentPacking::uint16_5_6_5_rev)
		.value("uint16_4_4_4_4", ContentPacking::uint16_4_4_4_4)
		.value("uint16_4_4_4_4_rev", ContentPacking::uint16_4_4_4_4_rev)
		.value("uint16_5_5_5_1", ContentPacking::uint16_5_5_5_1)
		.value("uint16_1_5_5_5_rev", ContentPacking::uint16_1_5_5_5_rev)
		.value("uint32_8_8_8_8", ContentPacking::uint32_8_8_8_8)
		.value("uint32_8_8_8_8_rev", ContentPacking::uint32_8_8_8_8_rev)
		.value("uint32_10_10_10_2", ContentPacking::uint32_10_10_10_2)
		.value("uint32_2_10_10_10_rev", ContentPacking::uint32_2_10_10_10_rev)
	;

	py::enum_<PixelFormat>("PixelFormat")
		.value("depth_component", PixelFormat::depth_component)
		.value("depth_stencil", PixelFormat::depth_stencil)
		.value("red", PixelFormat::red)
		.value("rg", PixelFormat::rg)
		.value("rgb", PixelFormat::rgb)
		.value("rgba", PixelFormat::rgba)

		.value("r8", PixelFormat::r8)
		.value("r8_snorm", PixelFormat::r8_snorm)
		.value("r16", PixelFormat::r16)
		.value("r16_snorm", PixelFormat::r16_snorm)
		.value("rg8", PixelFormat::rg8)
		.value("rg8_snorm", PixelFormat::rg8_snorm)
		.value("rg16", PixelFormat::rg16)
		.value("rg16_snorm", PixelFormat::rg16_snorm)
		.value("r3_g3_b2", PixelFormat::r3_g3_b2)
		.value("rgb4", PixelFormat::rgb4)
		.value("rgb5", PixelFormat::rgb5)
		.value("rgb8", PixelFormat::rgb8)
		.value("rgb8_snorm", PixelFormat::rgb8_snorm)
		.value("rgb10", PixelFormat::rgb10)
		.value("rgb12", PixelFormat::rgb12)
		.value("rgb16_snorm", PixelFormat::rgb16_snorm)
		.value("rgba2", PixelFormat::rgba2)
		.value("rgba4", PixelFormat::rgba4)
		.value("rgb5_a1", PixelFormat::rgb5_a1)
		.value("rgba8", PixelFormat::rgba8)
		.value("rgba8_snorm", PixelFormat::rgba8_snorm)
		.value("rgb10_a2", PixelFormat::rgb10_a2)
		.value("rgb10_a2ui", PixelFormat::rgb10_a2ui)
		.value("rgba12", PixelFormat::rgba12)
		.value("rgba16", PixelFormat::rgba16)
		.value("srgb8", PixelFormat::srgb8)
		.value("srgb8_alpha8", PixelFormat::srgb8_alpha8)
		.value("r16f", PixelFormat::r16f)
		.value("rg16f", PixelFormat::rg16f)
		.value("rgb16f", PixelFormat::rgb16f)
		.value("rgba16f", PixelFormat::rgba16f)
		.value("r32f", PixelFormat::r32f)
		.value("rg32f", PixelFormat::rg32f)
		.value("rgb32f", PixelFormat::rgb32f)
		.value("rgba32f", PixelFormat::rgba32f)
		.value("r11f_g11f_b10f", PixelFormat::r11f_g11f_b10f)
		.value("rgb9_e5", PixelFormat::rgb9_e5)
		.value("r8i", PixelFormat::r8i)
		.value("r8ui", PixelFormat::r8ui)
		.value("r16i", PixelFormat::r16i)
		.value("r16ui", PixelFormat::r16ui)
		.value("r32i", PixelFormat::r32i)
		.value("r32ui", PixelFormat::r32ui)
		.value("rg8i", PixelFormat::rg8i)
		.value("rg8ui", PixelFormat::rg8ui)
		.value("rg16i", PixelFormat::rg16i)
		.value("rg16ui", PixelFormat::rg16ui)
		.value("rg32i", PixelFormat::rg32i)
		.value("rg32ui", PixelFormat::rg32ui)
		.value("rgb8i", PixelFormat::rgb8i)
		.value("rgb8ui", PixelFormat::rgb8ui)
		.value("rgb16i", PixelFormat::rgb16i)
		.value("rgb16ui", PixelFormat::rgb16ui)
		.value("rgb32i", PixelFormat::rgb32i)
		.value("rgb32ui", PixelFormat::rgb32ui)
		.value("rgba8i", PixelFormat::rgba8i)
		.value("rgba8ui", PixelFormat::rgba8ui)
		.value("rgba16i", PixelFormat::rgba16i)
		.value("rgba16ui", PixelFormat::rgba16ui)
		.value("rgba32i", PixelFormat::rgba32i)
		.value("rgba32ui", PixelFormat::rgba32ui)

		.value("compressed_red", PixelFormat::compressed_red)
		.value("compressed_rg", PixelFormat::compressed_rg)
		.value("compressed_rgb", PixelFormat::compressed_rgb)
		.value("compressed_rgba", PixelFormat::compressed_rgba)
		.value("compressed_srgb", PixelFormat::compressed_srgb)
		.value("compressed_srgb_alpha", PixelFormat::compressed_srgb_alpha)
		//.value("compressed_red_rgtc1", PixelFormat::compressed_red_rgtc1)
		//.value("compressed_signed_red_rgtc1", PixelFormat::compressed_signed_red_rgtc1)
		//.value("compressed_rg_rgtc2", PixelFormat::compressed_rg_rgtc2)
		//.value("compressed_signed_rg_rgtc2", PixelFormat::compressed_signed_rg_rgtc2)
		//.value("compressed_rgba_bptc_unorm", PixelFormat::compressed_rgba_bptc_unorm)
		//.value("compressed_srgb_alpha_bptc_unorm", PixelFormat::compressed_srgb_alpha_bptc_unorm)
		//.value("compressed_rgb_bptc_signed_float", PixelFormat::compressed_rgb_bptc_signed_float)
		//.value("compressed_rgb_bptc_unsigned_float", PixelFormat::compressed_rgb_bptc_unsigned_float)
	;

	py::enum_<DrawMode>("DrawMode")
		.value("points", DrawMode::points)
		.value("lines", DrawMode::lines)
		.value("line_strip", DrawMode::line_strip)
		.value("line_loop", DrawMode::line_loop)
		.value("triangles", DrawMode::triangles)
		.value("triangle_strip", DrawMode::triangle_strip)
		.value("triangle_fan", DrawMode::triangle_fan)
		.value("quads", DrawMode::quads)
		.value("quad_strip", DrawMode::quad_strip)
		.value("polygon", DrawMode::polygon)
	;

	py::enum_<BufferBit>("BufferBit")
		.value("color", BufferBit::color)
		.value("depth", BufferBit::depth)
		.value("stencil", BufferBit::stencil)
	;

	///////////////////////////////////////////////////////////////////////////
	// Bindable

#define EXPORT_BINDABLE()                                                     \
	py::class_<                                                               \
		Bindable<>,                                                           \
		boost::noncopyable,                                                   \
		py::bases<BindableBase>                                               \
	>("Bindable", py::no_init)                                                \
/**/

	py::class_<BindableBase, boost::noncopyable>("BindableBase", py::no_init);
	EXPORT_BINDABLE();

	///////////////////////////////////////////////////////////////////////////
	// Drawable

#define EXPORT_DRAWABLE(...)                                                  \
	py::class_<                                                               \
		Drawable<__VA_ARGS__>,                                                \
		boost::noncopyable                                                    \
	>("Drawable", py::no_init)                                                \
/**/

	EXPORT_DRAWABLE();
	EXPORT_DRAWABLE(ShaderProgramParameter);

	///////////////////////////////////////////////////////////////////////////
	// State

	py::class_<State, boost::noncopyable>("State", py::no_init)
# define EXPORT_STATE_MATRIX(__name)                                          \
		.add_property(                                                        \
			#__name,                                                          \
			py::make_function(                                                \
				static_cast<                                                  \
					matrix_type const&(State::*)() const                      \
				>(&State::__name),                                            \
				py::return_internal_reference<>()                             \
			),                                                                \
			static_cast<void(State::*)(matrix_type const&)>(&State::__name)   \
		)                                                                     \
/**/
		EXPORT_STATE_MATRIX(model)
		EXPORT_STATE_MATRIX(view)
		EXPORT_STATE_MATRIX(projection)
		.add_property(
			"mvp",
			py::make_function(
				static_cast<
					matrix_type const&(State::*)() const
				>(&State::mvp),
				py::return_internal_reference<>()
			)
		)
		.def(
			"translate",
			&State::translate
		)
	;



	///////////////////////////////////////////////////////////////////////////
	// Painter

#define PAINTER_DRAW1(_P1) \
	static_cast<void(Painter::*)(Drawable<_P1>&, _P1&)>(&Painter::draw)

	py::class_<Painter, boost::noncopyable>(
			"Painter", py::no_init
		)
		.def(
			"bind",
			&Wrap::Painter::bind,
			py::args("drawable", "The drawable to bind."),
			"Bound drawables can be unbound with the `unbind' method but are"
			" automatically unbound when the painter is deleted."
		)
		.def(
			"unbind",
			&Painter::unbind
		)
		.def(
			"draw_elements",
			&Painter::draw_elements
		)
		.def(
			"draw",
			(void(Painter::*)(Drawable<>&)) &Painter::draw
		)
		.def(
			"draw",
			PAINTER_DRAW1(ShaderProgramParameter)
		)
		.add_property(
			"state",
			py::make_function(
				&Painter::state,
				py::return_internal_reference<>()
			)
		)
	;

	///////////////////////////////////////////////////////////////////////////
	// PainterWithProxy

	py::class_<detail::PainterWithProxy>(
			"PainterWithProxy", py::no_init
		)
		.def(
			"__enter__",
			&detail::PainterWithProxy::__enter__,
			py::return_internal_reference<1>()
		)
		.def(
			"__exit__",
			&Wrap::PainterWithProxy::__exit__
		)
	;

	///////////////////////////////////////////////////////////////////////////
	// Renderer

	typedef TexturePtr (Renderer::*new_texture_cb_t)(std::string const&);

	typedef TexturePtr (Renderer::*new_texture_raw_cb_t)(
		PixelFormat const,
		unsigned int,
		unsigned int,
		renderer::PixelFormat const,
		renderer::ContentPacking const,
		void const*
	);

	typedef ShaderPtr (Renderer::*new_fragment_shader_t)(
		std::vector<std::string> const&
	);

	typedef ShaderPtr (Renderer::*new_vertex_shader_t)(
		std::vector<std::string> const&
	);

	py::class_<Renderer, boost::shared_ptr<Renderer>, boost::noncopyable>(
			"Renderer", py::no_init
		)
		.def(
			"description",
			&Renderer::description,
			py::return_internal_reference<>()
		)
		.def(
			"swap_buffers",
			&Renderer::swap_buffers
		)
		.def(
			"viewport",
			&Wrap::Renderer::viewport
		)
		.def(
			"begin",
			&Wrap::Renderer::begin,
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<1,0>
			>()
		)
		.add_property(
			"state",
			py::make_function(
				&Renderer::current_state,
				py::return_internal_reference<>()
			)
		)
		.def(
			"new_vertex_buffer",
			&Wrap::Renderer::new_vertex_buffer,
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<1,0>
			>()
		)
		.def(
			"new_index_buffer",
			&Wrap::Renderer::new_index_buffer,
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<1,0>
			>()
		)
		.def(
			"new_shader_program",
			&Wrap::Renderer::new_shader_program,
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<1,0>
			>()
		)
		.def(
			"new_fragment_shader",
			static_cast<new_fragment_shader_t>(&Renderer::new_fragment_shader),
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<1,0>
			>()
		)
		.def(
			"new_vertex_shader",
			static_cast<new_vertex_shader_t>(&Renderer::new_vertex_shader),
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<1,0>
			>()
		)
		.def(
			"new_texture",
			static_cast<new_texture_cb_t>(
				&Renderer::new_texture
			),
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<1,0>
			>()
		)
		.def(
			"new_texture",
			static_cast<new_texture_raw_cb_t>(
				&Renderer::new_texture
			),
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<1,0>
			>()
		)
		.def(
			"clear",
			&Wrap::Renderer::clear
		)
	;

	///////////////////////////////////////////////////////////////////////////
	// RendererType

	py::class_<RendererType, boost::noncopyable>(
			"RendererType",
			py::no_init
		)
		.def(
			"__str__",
			&RendererType::__str__
		)
	;

	///////////////////////////////////////////////////////////////////////////
	// VertexBuffer

	py::class_<
			VertexBuffer,
			std::auto_ptr<VertexBuffer>,
			boost::noncopyable,
			py::bases<BindableBase>
		>(
			"VertexBuffer",
			py::no_init
		)
	;

	///////////////////////////////////////////////////////////////////////////
	// Shader

	py::class_<
			Shader,
			std::auto_ptr<Shader>,
			boost::noncopyable
		>(
			"Shader",
			py::no_init
		)
	;

	///////////////////////////////////////////////////////////////////////////
	// ShaderProgram

	{
		py::scope scope(py::class_<
				ShaderProgram,
				std::auto_ptr<ShaderProgram>,
				py::bases<BindableBase>,
				boost::noncopyable
			>(
				"ShaderProgram",
				py::no_init
			)
			.def(
				"parameter",
				&ShaderProgram::parameter,
				py::return_internal_reference<>()
			)
		);

	} // end of ShaderProgram scope

	///////////////////////////////////////////////////////////////////////////
	// ShaderProgramParameter

		py::class_<
				ShaderProgramParameter,
				boost::noncopyable
			>(
				"ShaderProgramParameter",
				py::no_init
			)
#define __EQ__(type)                                                          \
			.def(                                                             \
				"__eq__",                                                     \
				py::pure_virtual(                                             \
					static_cast<                                              \
						void                                                  \
						(ShaderProgramParameter::*) (type)                    \
					>(&ShaderProgramParameter::operator =)                    \
				)                                                             \
			)                                                                 \
	/**/
			__EQ__(matrix_type const&)
			__EQ__(int32_t)
			__EQ__(Texture&)
#undef __EQ__
		;

	///////////////////////////////////////////////////////////////////////////
	// Texture

	py::class_<
			Texture,
			std::auto_ptr<Texture>,
			boost::noncopyable,
			py::bases<BindableBase>
		>(
			"Texture",
			py::no_init
		)
		.def(
			"bind_unit",
			&Texture::bind_unit
		)
	;

	///////////////////////////////////////////////////////////////////////////
	// std::unique_ptr<T> to python converters.

#define PTR_TO_PYTHON(__type)                                                 \
	py::to_python_converter<                                                  \
		std::unique_ptr<__type>,                                              \
		Wrap::UniquePtrConverter<__type>                                      \
	>()                                                                       \
/**/

	PTR_TO_PYTHON(VertexBuffer);
	PTR_TO_PYTHON(ShaderProgram);
	PTR_TO_PYTHON(Shader);

}
