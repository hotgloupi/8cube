#include <etc/test/Registry.hpp>
#include <etc/test/Case.hpp>

#include <etc/log.hpp>
#include <etc/memory.hpp>
#include <etc/backtrace.hpp>

#include <cube/exception.hpp>

#include <cube/python.hpp>

using namespace etc::test;
namespace py = boost::python;

namespace {

	ETC_LOG_COMPONENT("cube.test.registry");

	class PythonTestCase
		: public Case
	{
		py::object _callable;

	public:
		PythonTestCase(py::object callable,
		               std::string file,
		               unsigned int line,
		               std::string name,
		               CaseSetupBase* setup)
			: Case(std::move(file), line, std::move(name), setup)
			, _callable{callable}
		{}

		void operator ()() override
		{ cube::python::propagate_exception(_callable); }
	};

	class PythonSetupTestCase
		: public CaseSetupBase
	{
	private:
		py::object _setup;
		py::object _teardown;

	public:
		PythonSetupTestCase(py::object setup, py::object teardown)
			: _setup(setup)
			, _teardown(teardown)
		{}
		void setUp() override { cube::python::propagate_exception(_setup); }
		void tearDown() override { cube::python::propagate_exception(_teardown); }
	};

	void registry_add(py::object setup,
	                  py::object teardown,
	                  py::object callable,
	                  std::string file,
	                  unsigned int line,
	                  std::string name)
	{
		auto case_setup = etc::make_unique<PythonSetupTestCase>(setup, teardown);
		new PythonTestCase(
			callable,
			std::move(file),
			line,
			std::move(name),
			case_setup.get()
		);
		case_setup.release();
	}

	bool registry_run() { return registry().run(); }
	bool registry_run_matching(std::string const& pattern)
	{ return registry().run(pattern); }

} // !anonymous

BOOST_PYTHON_MODULE(registry)
{

	py::def("add", &registry_add);
	py::def("run", &registry_run);
	py::def("run", &registry_run_matching);
}

