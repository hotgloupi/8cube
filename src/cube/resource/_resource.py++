#include "Resource.hpp"
#include "Manager.hpp"

#include <cube/python.hpp>

#include <cube/exception.hpp>
#include <etc/print.hpp>
#include <etc/to_string.hpp>

namespace {

	namespace py = boost::python;
	using namespace cube::resource;
	using cube::exception::Exception;


	size_t resource_refcount(Resource const& resource) ETC_NOEXCEPT
	{ return resource.shared_from_this().use_count() - 1; }

	struct WrapManager
	{
		static
		PyTypeObject const* get_resource_type()
		{
			auto ptr = py::converter::registered_pytype<Resource>::get_pytype();
			if (ptr == nullptr)
				throw Exception{"Couldn't find PyTypeObject for Resource class"};
			return ptr;
		}

		static
		py::object create(Manager& self,
		                  py::object type,
		                  py::tuple args,
		                  py::dict kw)
		{
			if (!PyType_Check(type.ptr()))
			{
				PyErr_SetString(
					PyExc_ValueError,
					"First argument should be a type"
				);
				throw py::error_already_set{};
			}
			static PyTypeObject const* const resource_type = get_resource_type();
			if (!PyType_IsSubtype((PyTypeObject*) type.ptr(),
			                      (PyTypeObject*) resource_type))
			{
				PyErr_SetString(
					PyExc_TypeError,
					"The resource type must be a subclass of Resource"
				);
				throw py::error_already_set{};
			}
			PyObject* result_ptr = PyObject_Call(type.ptr(), args.ptr(), kw.ptr());
			if (result_ptr == nullptr)
				throw py::error_already_set{};

			// Using py::handle<> or not has exactly the same effect ... Why ?
			//py::object result(py::handle<>(py::borrowed(result_ptr)));
			py::object result(py::borrowed(result_ptr));

			// It seems that even with borrowed(), the refcount is incremented
			Py_DECREF(result_ptr);


			try
			{
				ResourcePtr resource_ptr;
				// XXX Boost.Python does not honor storage specifications, it
				// does store the resource as a boost::shared_ptr<Resource>
				// instead of the std::shared_ptr<Resource> (as asked).  We try
				// first the correct behavior, then fallback to the hackish
				// way.
				try {
					resource_ptr = py::extract<Resource&>(result)().shared_ptr();
				} catch (...) {
					boost::shared_ptr<Resource> ptr =
						py::extract<boost::shared_ptr<Resource>>(result)();
					resource_ptr = ResourcePtr(
						ptr.get(), [ptr](Resource*) mutable {ptr.reset();}
					);
				}
				self.manage(resource_ptr);
			}
			catch (py::error_already_set const&)
			{
				PyErr_SetString(
					PyExc_TypeError,
					"Couldn't cast the created resource to the Resource type "
					"(You might have forgotten to call Resource.__init__)"
				);
				throw;
			}
			return result;
		}
		static
		std::shared_ptr<Resource> load(Manager& self, py::object cls, boost::filesystem::path path)
		{
			auto resource_path = self.find(path);
			if (self.loaded(resource_path))
			{
				return self.get(resource_path);
			}
			auto obj = create(self, cls, py::make_tuple(resource_path), py::dict());
			Resource& ref = py::extract<Resource&>(obj)();
			self.set_loaded(ref, path);
			return ref.shared_ptr();
		}

		static
		std::shared_ptr<Resource> manage(Manager& self, Resource& r)
		{
			return self.manage(r);
		}

		static void add_path(Manager& self, std::string const& p)
		{ self.add_path(p); }
	};

}

BOOST_PYTHON_MODULE(_resource)
{
	namespace py = boost::python;
	using namespace cube::resource;

	py::class_<
		Resource,
		ResourcePtr,
		boost::noncopyable
	>(
		"Resource"
	)
		.add_property("id", &Resource::id)
		.add_property("managed", &Resource::managed)
		.add_property("refcount", &resource_refcount)
	;

	py::class_<
		Manager,
		boost::noncopyable,
		std::auto_ptr<Manager>
	>(
		"_Manager"
	)
		.def("manage", &WrapManager::manage, py::with_custodian_and_ward<2, 1>())
		.def("forget", &Manager::forget)
		.def("add_path", &WrapManager::add_path)
		.def("load", &WrapManager::load)
		.def(
			"create",
			&WrapManager::create,
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<0, 1>
			>()
		)
	;

}
