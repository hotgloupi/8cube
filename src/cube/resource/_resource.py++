#include "Resource.hpp"
#include "Manager.hpp"

#include <wrappers/boost/python.hpp>

#include <cube/exception.hpp>
#include <etc/print.hpp>

namespace {

	namespace py = boost::python;
	using namespace cube::resource;
	using cube::exception::Exception;

	struct WrapResource
		: public Resource
	{
		WrapResource()
			: Resource{}
		{}

		~WrapResource()
		{}

		size_t refcount() const noexcept
		{ return this->shared_from_this().use_count() - 1; }
	};

	struct WrapManager
	{
		static
		PyTypeObject const* get_resource_type()
		{
			auto ptr = py::converter::registered_pytype<Resource>::get_pytype();
			if (ptr == nullptr)
				throw Exception{"Couldn't find PyTypeObject for Resource class"};
			return ptr;
		}

		static
		py::object create(py::tuple args, py::dict kw)
		{
			Manager& self = py::extract<Manager&>(args[0]);
			py::object type{args[1]};
			if (!PyType_Check(type.ptr()))
			{
				PyErr_SetString(
					PyExc_ValueError,
					"First argument should be a type"
				);
				throw py::error_already_set{};
			}
			static PyTypeObject const* const resource_type = get_resource_type();
			if (!PyType_IsSubtype((PyTypeObject*) type.ptr(),
			                      (PyTypeObject*) resource_type))
			{
				PyErr_SetString(
					PyExc_TypeError,
					"The resource type must be a subclass of Resource"
				);
				throw py::error_already_set{};
			}
			py::tuple ctor_args{args.slice(2, py::len(args))};
			PyObject* result_ptr = PyObject_Call(type.ptr(), ctor_args.ptr(), kw.ptr());
			if (result_ptr == nullptr)
				throw py::error_already_set{};

			// Using py::handle<> or not has exactly the same effect ... Why ?
			//py::object result(py::handle<>(py::borrowed(result_ptr)));
			py::object result(py::borrowed(result_ptr));

			// It seems that even with borrowed(), the refcount is incremented
			Py_DECREF(result_ptr);

			try
			{
				self.manage(py::extract<Resource&>(result));
			}
			catch (py::error_already_set const&)
			{
				PyErr_SetString(
					PyExc_TypeError,
					"Couldn't cast the created resource to the Resource type "
					"(You might have forgotten to call Resource.__init__)"
				);
				throw;
			}
			return result;
		}
	};

}

BOOST_PYTHON_MODULE(_resource)
{
	namespace py = boost::python;
	using namespace cube::resource;

	py::class_<Resource, boost::noncopyable>("_Resource", py::no_init);
	py::class_<
		WrapResource,
		std::shared_ptr<WrapResource>,
		boost::noncopyable,
		py::bases<Resource>
	>(
		"Resource"
	)
		.add_property("id", &WrapResource::id)
		.add_property("managed", &WrapResource::managed)
		.add_property("refcount", &WrapResource::refcount)
	;

	py::class_<
		Manager,
		boost::noncopyable,
		std::auto_ptr<Manager>
	>(
		"Manager"
	)
		.def("manage", &Manager::manage)
		.def("forget", &Manager::forget)
		.def("create", py::raw_function(&WrapManager::create, /*min_args*/ 2))
	;

}
