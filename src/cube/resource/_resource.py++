#include "Resource.hpp"
#include "Manager.hpp"

#include <wrappers/boost/python.hpp>

#include <cube/exception.hpp>
#include <etc/print.hpp>
#include <etc/to_string.hpp>

namespace {

	namespace py = boost::python;
	using namespace cube::resource;
	using cube::exception::Exception;


	size_t resource_refcount(Resource const& resource) noexcept
	{ return resource.shared_from_this().use_count() - 1; }

	struct WrapManager
	{
		static
		PyTypeObject const* get_resource_type()
		{
			auto ptr = py::converter::registered_pytype<Resource>::get_pytype();
			if (ptr == nullptr)
				throw Exception{"Couldn't find PyTypeObject for Resource class"};
			return ptr;
		}

		static
		py::object create(Manager& self,
		                  py::object type,
		                  py::tuple args,
		                  py::dict kw)
		{
			if (!PyType_Check(type.ptr()))
			{
				PyErr_SetString(
					PyExc_ValueError,
					"First argument should be a type"
				);
				throw py::error_already_set{};
			}
			static PyTypeObject const* const resource_type = get_resource_type();
			if (!PyType_IsSubtype((PyTypeObject*) type.ptr(),
			                      (PyTypeObject*) resource_type))
			{
				PyErr_SetString(
					PyExc_TypeError,
					"The resource type must be a subclass of Resource"
				);
				throw py::error_already_set{};
			}
			PyObject* result_ptr = PyObject_Call(type.ptr(), args.ptr(), kw.ptr());
			if (result_ptr == nullptr)
				throw py::error_already_set{};

			// Using py::handle<> or not has exactly the same effect ... Why ?
			//py::object result(py::handle<>(py::borrowed(result_ptr)));
			py::object result(py::borrowed(result_ptr));

			// It seems that even with borrowed(), the refcount is incremented
			Py_DECREF(result_ptr);

			try
			{
				self.manage(
					static_cast<Resource&>(py::extract<Resource&>(result))
				);
			}
			catch (py::error_already_set const&)
			{
				PyErr_SetString(
					PyExc_TypeError,
					"Couldn't cast the created resource to the Resource type "
					"(You might have forgotten to call Resource.__init__)"
				);
				throw;
			}
			return result;
		}

		static
		std::shared_ptr<Resource> manage(Manager& self, Resource& r)
		{
			return self.manage(r);
		}
	};

}

BOOST_PYTHON_MODULE(_resource)
{
	namespace py = boost::python;
	using namespace cube::resource;

	py::class_<
		Resource,
		ResourcePtr,
		boost::noncopyable
	>(
		"Resource"
	)
		.add_property("id", &Resource::id)
		.add_property("managed", &Resource::managed)
		.add_property("refcount", &resource_refcount)
	;

	py::class_<
		Manager,
		boost::noncopyable,
		std::auto_ptr<Manager>
	>(
		"_Manager"
	)
		.def("manage", &WrapManager::manage, py::with_custodian_and_ward<2, 1>())
		.def("forget", &Manager::forget)
		.def(
			"create",
			&WrapManager::create,
			py::return_value_policy<
				py::return_by_value,
				py::with_custodian_and_ward_postcall<0, 1>
			>()
		)
	;

}
