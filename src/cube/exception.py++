#include <wrappers/boost/python.hpp>

#include "exception.hpp"

#include <etc/backtrace.hpp>
#include <etc/to_string.hpp>
#include <etc/types.hpp>

namespace py = boost::python;

namespace {

	static PyObject* ExceptionType = nullptr;

	// from http://stackoverflow.com/questions/9620268/boost-python-custom-exception-class
	PyObject*
	create_exception_type(const char* name,
	                      PyObject* baseTypeObj = PyExc_Exception)
	{
		std::string scopeName = py::extract<std::string>(py::scope().attr("__name__"));
		std::string qualifiedName0 = scopeName + "." + name;
		char* qualifiedName1 = const_cast<char*>(qualifiedName0.c_str());

		PyObject* typeObj = PyErr_NewException(qualifiedName1, baseTypeObj, 0);
		if(!typeObj) py::throw_error_already_set();
		py::scope().attr(name) = py::handle<>(py::borrowed(typeObj));
		return typeObj;
	}


	void translator(cube::exception::Exception const& e)
	{
		py::list backtrace;
		if (auto const& bt = e.backtrace())
		{
			for (auto const& frame: *bt)
				backtrace.append(etc::to_string(frame));
		}
		py::object exception_type(py::handle<>(py::borrowed(ExceptionType)));
		exception_type.attr("backtrace") = backtrace;

		PyErr_SetString(ExceptionType, e.what());
	}

} // !anonymous

namespace {

	void test_throw(std::string const& str)
	{
		throw cube::exception::Exception(str);
	}

	void test_cb(py::object cb)
	{ cb(); }

}

BOOST_PYTHON_MODULE(exception)
{
	BOOST_PYTHON_DOCSTRING_OPTIONS();

	ExceptionType = create_exception_type("Exception");
	py::register_exception_translator<cube::exception::Exception>(&translator);
	py::def("test_throw", &test_throw);
	py::def("test_cb", &test_cb);
}
